<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDFWATERMARK3.0</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“„</text></svg>">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .mode-selection {
            margin-bottom: 30px;
        }

        .mode-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-btn {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 600;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .input-group {
            margin-bottom: 25px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px dashed #667eea;
            border-radius: 10px;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .watermark-list {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
        }

        .watermark-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }

        .watermark-item:last-child {
            margin-bottom: 0;
        }

        .remove-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .add-btn {
            background: #2ed573;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 10px;
        }

        .process-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .process-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e1e5e9;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .hidden {
            display: none;
        }

        .file-list {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            padding: 8px 12px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.9em;
            border-left: 4px solid #667eea;
        }

        .file-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“„ PDFWATERMARK3.0</h1>
            <p>ë³µìˆ˜ì˜ PDFì— ì›Œí„°ë§ˆí¬ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ í•˜ë‚˜ì˜ PDFì— ì—¬ëŸ¬ ì›Œí„°ë§ˆí¬ë¥¼ ì ìš©í•˜ì„¸ìš”</p>
            <p style="font-size: 0.8em; opacity: 0.7; margin-top: 10px;">by.cchomath</p>
        </div>

        <div class="content">
            <div class="mode-selection">
                <h3>ì‘ì—… ëª¨ë“œ ì„ íƒ</h3>
                <div class="mode-buttons">
                    <button class="mode-btn active" data-mode="multiple-pdf">
                        ë³µìˆ˜ PDF + ê°™ì€ ì›Œí„°ë§ˆí¬
                    </button>
                    <button class="mode-btn" data-mode="single-pdf">
                        1ê°œ PDF + ë³µìˆ˜ ì›Œí„°ë§ˆí¬
                    </button>
                </div>
            </div>

            <!-- Mode 1: Multiple PDFs, Same Watermark -->
            <div id="mode-multiple-pdf" class="mode-content">
                <div class="input-group">
                    <label for="pdf-files">PDF íŒŒì¼ë“¤ ì„ íƒ (ë³µìˆ˜ ì„ íƒ ê°€ëŠ¥)</label>
                    <input type="file" id="pdf-files" class="file-input" multiple accept=".pdf">
                    <div id="pdf-file-list" class="file-list hidden"></div>
                </div>

                <div class="input-group">
                    <label for="watermark-text">ì›Œí„°ë§ˆí¬ í…ìŠ¤íŠ¸ (ì˜ì–´ë§Œ ì¸ì‹ë©ë‹ˆë‹¤)</label>
                    <input type="text" id="watermark-text" placeholder="ì˜ˆ: CONFIDENTIAL, SAMPLE, CSM17 ë“±">
                </div>
            </div>

            <!-- Mode 2: Single PDF, Multiple Watermarks -->
            <div id="mode-single-pdf" class="mode-content hidden">
                <div class="input-group">
                    <label for="single-pdf-file">PDF íŒŒì¼ ì„ íƒ</label>
                    <input type="file" id="single-pdf-file" class="file-input" accept=".pdf">
                </div>

                <div class="input-group">
                    <label>ì›Œí„°ë§ˆí¬ í…ìŠ¤íŠ¸ë“¤ (ì˜ì–´ë§Œ ì¸ì‹ë©ë‹ˆë‹¤)</label>
                    <div class="watermark-input-container">
                        <input type="text" id="new-watermark-text" placeholder="ì˜ˆ: CONFIDENTIAL, SAMPLE, CSM17 ë“±">
                        <button class="add-btn" onclick="addWatermark()">ì¶”ê°€</button>
                    </div>
                    <div id="watermark-list" class="watermark-list">
                        <!-- ì›Œí„°ë§ˆí¬ ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                    </div>
                </div>
            </div>

            <button class="process-btn" onclick="processWatermark()">ì›Œí„°ë§ˆí¬ ì ìš©</button>

            <div class="progress" id="progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div id="progress-text">ì²˜ë¦¬ ì¤‘...</div>
            </div>
        </div>
    </div>

    <script>
        let currentMode = 'multiple-pdf';
        let watermarkTexts = [];

        // ëª¨ë“œ ì „í™˜
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                currentMode = btn.dataset.mode;

                document.querySelectorAll('.mode-content').forEach(content => {
                    content.classList.add('hidden');
                });
                document.getElementById(`mode-${currentMode}`).classList.remove('hidden');
            });
        });

        // íŒŒì¼ ì„ íƒ ì²˜ë¦¬
        document.getElementById('pdf-files').addEventListener('change', function(e) {
            const fileList = document.getElementById('pdf-file-list');
            const files = Array.from(e.target.files);

            if (files.length > 0) {
                fileList.classList.remove('hidden');
                fileList.innerHTML = files.map(file =>
                    `<div class="file-item">${file.name}</div>`
                ).join('');
            } else {
                fileList.classList.add('hidden');
            }
        });

        // ì›Œí„°ë§ˆí¬ ì¶”ê°€
        function addWatermark() {
            const input = document.getElementById('new-watermark-text');
            const text = input.value.trim();

            if (text && !watermarkTexts.includes(text)) {
                watermarkTexts.push(text);
                updateWatermarkList();
                input.value = '';
            }
        }

        // ì›Œí„°ë§ˆí¬ ì œê±°
        function removeWatermark(index) {
            watermarkTexts.splice(index, 1);
            updateWatermarkList();
        }

        // ì›Œí„°ë§ˆí¬ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateWatermarkList() {
            const list = document.getElementById('watermark-list');
            list.innerHTML = watermarkTexts.map((text, index) =>
                `<div class="watermark-item">
                    <span>${text}</span>
                    <button class="remove-btn" onclick="removeWatermark(${index})">ì œê±°</button>
                </div>`
            ).join('');
        }

        // Enter í‚¤ë¡œ ì›Œí„°ë§ˆí¬ ì¶”ê°€
        document.getElementById('new-watermark-text').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addWatermark();
            }
        });

        // PDF ì²˜ë¦¬ í•¨ìˆ˜
        async function processWatermark() {
            const progressDiv = document.getElementById('progress');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const processBtn = document.querySelector('.process-btn');

            try {
                processBtn.disabled = true;
                progressDiv.style.display = 'block';

                if (currentMode === 'multiple-pdf') {
                    await processMultiplePDFs();
                } else {
                    await processSinglePDF();
                }

                progressText.textContent = 'ì™„ë£Œ!';

            } catch (error) {
                alert('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                progressText.textContent = 'ì˜¤ë¥˜ ë°œìƒ';
            } finally {
                processBtn.disabled = false;
                setTimeout(() => {
                    progressDiv.style.display = 'none';
                    progressFill.style.width = '0%';
                }, 2000);
            }
        }

        // ë³µìˆ˜ PDF ì²˜ë¦¬
        async function processMultiplePDFs() {
            const files = document.getElementById('pdf-files').files;
            const watermarkText = document.getElementById('watermark-text').value.trim();

            if (files.length === 0 || !watermarkText) {
                throw new Error('PDF íŒŒì¼ê³¼ ì›Œí„°ë§ˆí¬ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            }

            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                progressText.textContent = `ì²˜ë¦¬ ì¤‘: ${file.name} (${i + 1}/${files.length})`;
                progressFill.style.width = `${(i / files.length) * 100}%`;

                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);

                await addWatermarkToPDF(pdfDoc, watermarkText);

                const pdfBytes = await pdfDoc.save();
                const fileName = file.name.replace('.pdf', '_watermarked.pdf');
                downloadPDF(pdfBytes, fileName);
            }

            progressFill.style.width = '100%';
        }

        // ë‹¨ì¼ PDF ì²˜ë¦¬
        async function processSinglePDF() {
            const file = document.getElementById('single-pdf-file').files[0];

            if (!file || watermarkTexts.length === 0) {
                throw new Error('PDF íŒŒì¼ê³¼ ì›Œí„°ë§ˆí¬ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            }

            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');

            const arrayBuffer = await file.arrayBuffer();

            for (let i = 0; i < watermarkTexts.length; i++) {
                const watermarkText = watermarkTexts[i];
                progressText.textContent = `ì²˜ë¦¬ ì¤‘: ${watermarkText} (${i + 1}/${watermarkTexts.length})`;
                progressFill.style.width = `${(i / watermarkTexts.length) * 100}%`;

                const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                await addWatermarkToPDF(pdfDoc, watermarkText);

                const pdfBytes = await pdfDoc.save();
                const fileName = file.name.replace('.pdf', `_${watermarkText}.pdf`);
                downloadPDF(pdfBytes, fileName);
            }

            progressFill.style.width = '100%';
        }

        // í•œê¸€ í°íŠ¸ ìºì‹œ
        let koreanFont = null;

        // í•œê¸€ í°íŠ¸ ë¡œë“œ í•¨ìˆ˜
        async function loadKoreanFont(pdfDoc) {
            if (koreanFont) return koreanFont;

            try {
                // ì—¬ëŸ¬ í°íŠ¸ URL ì‹œë„
                const fontUrls = [
                    'https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_two@1.0/S-CoreDream-3Light.woff',
                    'https://fonts.gstatic.com/ea/notosanskr/v2/NotoSansKR-Regular.woff2',
                    'https://cdn.rawgit.com/moonspam/NanumSquare/master/nanumsquare/nanumSquareRegular.woff'
                ];

                for (const url of fontUrls) {
                    try {
                        console.log(`í°íŠ¸ ë¡œë”© ì‹œë„: ${url}`);
                        const response = await fetch(url, { mode: 'cors' });
                        if (response.ok) {
                            const fontBytes = await response.arrayBuffer();
                            koreanFont = await pdfDoc.embedFont(fontBytes);
                            console.log('í•œê¸€ í°íŠ¸ ë¡œë”© ì„±ê³µ');
                            return koreanFont;
                        }
                    } catch (error) {
                        console.warn(`í°íŠ¸ ë¡œë”© ì‹¤íŒ¨: ${url}`, error);
                        continue;
                    }
                }

                // ëª¨ë“  ì™¸ë¶€ í°íŠ¸ ì‹¤íŒ¨ì‹œ ê¸°ë³¸ í°íŠ¸ ì‚¬ìš©
                console.log('ì™¸ë¶€ í°íŠ¸ ë¡œë”© ì‹¤íŒ¨, ê¸°ë³¸ í°íŠ¸ ì‚¬ìš©');
                koreanFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                return koreanFont;

            } catch (error) {
                console.error('í°íŠ¸ ë¡œë”© ì¤‘ ì˜¤ë¥˜:', error);
                koreanFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                return koreanFont;
            }
        }

        // í…ìŠ¤íŠ¸ê°€ í•œê¸€ì¸ì§€ í™•ì¸
        function hasKorean(text) {
            return /[ã„±-ã…|ã…-ã…£|ê°€-í£]/.test(text);
        }

        // í•œê¸€ì„ ì˜ì–´ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ (ë” í¬ê´„ì )
        function convertKoreanToEnglish(text) {
            // ì™„ì „í•œ ë‹¨ì–´ ë§¤í•‘ (ìš°ì„ ìˆœìœ„)
            const completeWordMapping = {
                'ì”¨ì—ìŠ¤ì— 17': 'CSM17',
                'ê¸°ë°€': 'CONFIDENTIAL',
                'ê¸°ë°€ë¬¸ì„œ': 'CONFIDENTIAL',
                'ìƒ˜í”Œ': 'SAMPLE',
                'í…ŒìŠ¤íŠ¸': 'TEST',
                'íšŒì‚¬': 'COMPANY',
                'ë¬¸ì„œ': 'DOCUMENT',
                'ë³µì‚¬ê¸ˆì§€': 'DO_NOT_COPY',
                'ì„ì‹œ': 'DRAFT',
                'ì´ˆì•ˆ': 'DRAFT',
                'ë‚´ë¶€ìš©': 'INTERNAL_USE'
            };

            // ì™„ì „ ì¼ì¹˜í•˜ëŠ” ê²½ìš°
            if (completeWordMapping[text]) {
                return completeWordMapping[text];
            }

            // ê°œë³„ ê¸€ì ë§¤í•‘
            const charMapping = {
                'ê°€': 'GA', 'ë‚˜': 'NA', 'ë‹¤': 'DA', 'ë¼': 'RA', 'ë§ˆ': 'MA', 'ë°”': 'BA', 'ì‚¬': 'SA', 'ì•„': 'A', 'ì': 'JA', 'ì°¨': 'CHA', 'ì¹´': 'KA', 'íƒ€': 'TA', 'íŒŒ': 'PA', 'í•˜': 'HA',
                'ê°‘': 'GAB', 'ì„': 'EUL', 'ë³‘': 'BYEONG', 'ì •': 'JEONG', 'ë¬´': 'MU', 'ê¸°': 'GI', 'ê²½': 'GYEONG', 'ì‹ ': 'SIN', 'ì„': 'IM', 'ê³„': 'GYE',
                'ì”¨': 'C', 'ì—': 'S', 'ìŠ¤': 'S', 'ì— ': 'M', 'ì´': 'I', 'ì˜¤': 'O', 'ìš°': 'U', 'ì–´': 'EO', 'ìœ¼': 'EU',
                'ê¹€': 'KIM', 'ì´': 'LEE', 'ë°•': 'PARK', 'ìµœ': 'CHOI', 'ì •': 'JUNG', 'ê°•': 'KANG', 'ì¡°': 'CHO', 'ìœ¤': 'YOON', 'ì¥': 'JANG', 'ì„': 'LIM',
                'íšŒ': 'HOE', 'ë™': 'DONG', 'ë‚¨': 'NAM', 'ì„œ': 'SEO', 'ë¶': 'BUK', 'ì¤‘': 'JUNG', 'ëŒ€': 'DAE', 'ì†Œ': 'SO', 'ê³ ': 'GO', 'ì €': 'JEO',
                'í•œ': 'HAN', 'êµ­': 'GUK', 'ë¯¼': 'MIN', 'ì£¼': 'JU', 'ê³µ': 'GONG', 'í™”': 'HWA', 'ê°œ': 'GAE', 'ë°œ': 'BAL', 'ì—°': 'YEON', 'êµ¬': 'GU'
            };

            // ê¸€ìë³„ë¡œ ë³€í™˜
            let result = '';
            for (let char of text) {
                if (/[ê°€-í£]/.test(char)) {
                    result += charMapping[char] || char.charCodeAt(0).toString(16).toUpperCase();
                } else {
                    result += char;
                }
            }

            return result;
        }

        // í•œê¸€ ì²˜ë¦¬: í•œê¸€ì´ ì•ˆë˜ë©´ ì˜ì–´ë¡œ ë³€í™˜
        function getDisplayText(originalText) {
            // í•œê¸€ì„ ì˜ì–´ë¡œ ë³€í™˜í•˜ëŠ” ë§¤í•‘
            const koreanMapping = {
                'ì”¨ì—ìŠ¤ì— 17': 'CSM17',
                'ì”¨ì—ìŠ¤ì— ': 'CSM',
                'ê¸°ë°€': 'CONFIDENTIAL',
                'ê¸°ë°€ë¬¸ì„œ': 'CONFIDENTIAL DOCUMENT',
                'ìƒ˜í”Œ': 'SAMPLE',
                'í…ŒìŠ¤íŠ¸': 'TEST',
                'íšŒì‚¬': 'COMPANY',
                'ë¬¸ì„œ': 'DOCUMENT',
                'ë³µì‚¬ê¸ˆì§€': 'DO NOT COPY',
                'ì„ì‹œ': 'DRAFT',
                'ì´ˆì•ˆ': 'DRAFT',
                'ë‚´ë¶€ìš©': 'INTERNAL USE',
                'ë¹„ë°€': 'SECRET',
                'ì¤‘ìš”': 'IMPORTANT'
            };

            // ì™„ì „ ë§¤ì¹­ ìš°ì„ 
            if (koreanMapping[originalText]) {
                return koreanMapping[originalText];
            }

            // í•œê¸€ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ê¸€ìë³„ ë³€í™˜
            if (hasKorean(originalText)) {
                const charMapping = {
                    'ì”¨': 'C', 'ì—': 'S', 'ìŠ¤': 'S', 'ì— ': 'M',
                    'ê°€': 'GA', 'ë‚˜': 'NA', 'ë‹¤': 'DA', 'ë¼': 'RA', 'ë§ˆ': 'MA',
                    'ë°”': 'BA', 'ì‚¬': 'SA', 'ì•„': 'A', 'ì': 'JA', 'ì°¨': 'CHA',
                    'ì¹´': 'KA', 'íƒ€': 'TA', 'íŒŒ': 'PA', 'í•˜': 'HA',
                    'ê¹€': 'KIM', 'ì´': 'LEE', 'ë°•': 'PARK', 'ìµœ': 'CHOI',
                    'ì •': 'JUNG', 'ê°•': 'KANG', 'ì¡°': 'CHO', 'ìœ¤': 'YOON',
                    'í•œ': 'HAN', 'êµ­': 'GUK', 'ëŒ€': 'DAE', 'í•™': 'HAK'
                };

                let result = '';
                for (let char of originalText) {
                    if (/[ê°€-í£]/.test(char)) {
                        result += charMapping[char] || char.charCodeAt(0).toString().slice(-2);
                    } else {
                        result += char;
                    }
                }
                return result;
            }

            return originalText;
        }

        // PDFì— ì›Œí„°ë§ˆí¬ ì¶”ê°€
        async function addWatermarkToPDF(pdfDoc, watermarkText) {
            console.log('ì›ë³¸ ì›Œí„°ë§ˆí¬ í…ìŠ¤íŠ¸:', watermarkText);
            const pages = pdfDoc.getPages();
            console.log('í˜ì´ì§€ ìˆ˜:', pages.length);

            // í•œê¸€ì„ ì˜ì–´ë¡œ ë³€í™˜ (í•œê¸€ í°íŠ¸ê°€ ì•ˆë˜ë¯€ë¡œ)
            const actualWatermarkText = getDisplayText(watermarkText);
            console.log('ìµœì¢… ì›Œí„°ë§ˆí¬ í…ìŠ¤íŠ¸:', actualWatermarkText);

            // í•­ìƒ ê¸°ë³¸ í°íŠ¸ ì‚¬ìš© (í™•ì‹¤í•œ ë°©ë²•)
            const font = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);

            for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                const page = pages[pageIndex];
                const { width, height } = page.getSize();
                console.log(`í˜ì´ì§€ ${pageIndex + 1} í¬ê¸°: ${width}x${height}`);

                // í°íŠ¸ í¬ê¸°ì™€ ê°„ê²© ì¡°ì • (ê²¹ì¹¨ ë¬¸ì œ í•´ê²°)
                const fontSize = Math.min(width, height) / 15; // í°íŠ¸ í¬ê¸° ì¤„ì„

                // í…ìŠ¤íŠ¸ ê¸¸ì´ì— ë”°ë¥¸ ë™ì  ê°„ê²© ê³„ì‚°
                const textWidth = actualWatermarkText.length * fontSize * 0.6; // ëŒ€ëµì ì¸ í…ìŠ¤íŠ¸ ë„ˆë¹„
                const minSpacing = textWidth + fontSize; // ìµœì†Œ ê°„ê²© = í…ìŠ¤íŠ¸ ë„ˆë¹„ + ì—¬ë°±
                const spacingX = Math.max(minSpacing, fontSize * 5); // Xì¶• ê°„ê²©
                const spacingY = Math.max(minSpacing * 0.7, fontSize * 3); // Yì¶• ê°„ê²© (ë” ì¡°ë°€í•˜ê²Œ)

                console.log('ìµœì¢… ì›Œí„°ë§ˆí¬ í…ìŠ¤íŠ¸:', actualWatermarkText);
                console.log('í°íŠ¸ í¬ê¸°:', fontSize);
                console.log('í…ìŠ¤íŠ¸ ì˜ˆìƒ ë„ˆë¹„:', textWidth);
                console.log('Xì¶• ê°„ê²©:', spacingX, 'Yì¶• ê°„ê²©:', spacingY);

                let textCount = 0;

                // ì‹œì‘ì ì„ ì¡°ì •í•˜ì—¬ ë” ê· ë“±í•˜ê²Œ ë°°ì¹˜
                const startX = -textWidth;
                const startY = -fontSize;

                for (let x = startX; x < width + textWidth; x += spacingX) {
                    for (let y = startY; y < height + fontSize; y += spacingY) {
                        try {
                            page.drawText(actualWatermarkText, {
                                x: x,
                                y: y,
                                size: fontSize,
                                font: font,
                                color: PDFLib.rgb(0.8, 0.8, 0.8), // ë” ì—°í•˜ê²Œ
                                opacity: 0.3, // ë” ì—°í•˜ê²Œ
                                rotate: PDFLib.degrees(-45),
                            });
                            textCount++;
                        } catch (textError) {
                            console.warn('í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° ì‹¤íŒ¨:', textError);
                            console.warn('ì‹¤íŒ¨í•œ í…ìŠ¤íŠ¸:', actualWatermarkText);
                        }
                    }
                }
                console.log(`í˜ì´ì§€ ${pageIndex + 1}ì— ${textCount}ê°œ ì›Œí„°ë§ˆí¬ ì¶”ê°€ë¨`);
            }
        }

        // PDF ë‹¤ìš´ë¡œë“œ
        function downloadPDF(pdfBytes, fileName) {
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>